#!/usr/bin/python
#
# Given a pom.xml file, turn it into a BUILD file.
#
# This script generates BUILD.gen files and BUILD.aux files.
# BUILD.gen files are generated where no BUILD file exists, filling the same purpose as a
#   handwritten BUILD file would.
# BUILD.aux files are generated /beside/ handwritten BUILD files. All their target names have the
#   'aux-' prefix to avoid collision. The purpose of these is to provide an easy way to maintain
#   dependencies in handwritten BUILD files, simply by referencing the generated dependency list in
#   the adjacent BUILD.aux file. This alleviates the amount of manual work that has to be done to
#   keep handwritten up to date with changin pom.xml's. All target types in BUILD.aux's are forced
#   to be dependencies(), resources(), or jar_library(), to prevent overlapping sources.
#   BUILD.aux files are excluded from the command line when invoking ./pants, but are still pulled
#   in when normal BUILD files reference them in their dependencies.
#

import logging
import sys
import os.path

from pom_handlers import DepsFromPom
from pom_utils import PomUtils
from target_template import Target


_BUILD_FILE_NAME="BUILD.gen"
_AUX_BUILD_FILE_NAME="BUILD.aux"
_HAND_WRITTEN_BUILD_FILE_NAME="BUILD"
_TARGET_ANNOTATION_PROCESSOR = "annotation_processor"
_TARGET_JAVA_LIBRARY = "java_library"
_TARGET_PROTOBUF_LIBRARY = "java_protobuf_library"
_TARGET_JUNIT_TESTS = "junit_tests"
_TARGET_RESOURCES = "resources"


logger = logging.getLogger(__name__)

class PomToBuild():

  def __init__(self):
    pass

  def write_sources_BUILD(self, pom_dir, path, target_type, target_name, deps, jar_deps=[],
      resources=None):
    """Writes the BUILD file that contains the source file references.
    """
    glob_map = {
      _TARGET_JAVA_LIBRARY: '*.java',
      _TARGET_ANNOTATION_PROCESSOR: '*.java',
      _TARGET_JUNIT_TESTS: '*.java',
      _TARGET_PROTOBUF_LIBRARY: '*.proto',
      _TARGET_RESOURCES: '*',
    }
    if target_type not in glob_map:
      raise Exception("I can't handle target_type: %s" % (target_type))
    glob = glob_map[target_type]

    # testing-support is a <scope>test</scope> dependency declared in parents/base/pom.xml.
    # To work right in pants, projects that directly used this would declare it in pom.xml, but
    # that would be a big change.  We also considered adding it to parent/base/BUILD but then
    # test-support classes would get into shaded jars so manually adding it to all test targets
    # is the next best thing.
    if target_type == _TARGET_JUNIT_TESTS:
      deps.append("'testing-support/src/main/java:lib'")

    build_file_path = os.path.join(pom_dir, path)
    if resources is None or target_type == _TARGET_RESOURCES:
      resources = []
    exclude_build = "- globs('BUILD*')" if target_type == _TARGET_RESOURCES else ''
    sources = "rglobs('%s') %s" % (glob, exclude_build)
    jar_contents = self.format_jar_deps(jar_deps, build_file_path)
    jar_target = ("    ':{jar_files}',\n"
                  .format(jar_files=infer_target_name(build_file_path, 'jar_files'))
                                    if jar_contents else '')

    contents = """# {filepath}
# Automatically generated by {gen_script}
""".format(filepath=infer_build_name(build_file_path), gen_script=os.path.basename(sys.argv[0]))

    if target_type == _TARGET_JUNIT_TESTS:
      # Tack on a java_library target
      contents += Target.get_template('junit_tests').format(
          name=infer_target_name(build_file_path, 'test'),
          sources=sources,
          dependencies=["':{lib}',".format(lib=infer_target_name(build_file_path, 'lib'))],
      )
      contents += Target.get_template('java_library').format(
        name=infer_target_name(build_file_path, 'lib'),
        sources=sources,
        resources=resources,
        dependencies=self.format_deps(_TARGET_JAVA_LIBRARY, deps, jar_target),
      )
      contents += self.format_jar_deps(jar_deps, build_file_path)
    else:
      contents += Target.get_template(target_type).format(
        name=infer_target_name(build_file_path, target_name),
        sources=sources,
        resources=resources,
        dependencies=self.format_deps(target_type, deps, jar_target),
        imports=[jar_target] if jar_target else [],
      )
      contents += self.format_jar_deps(jar_deps, build_file_path)
    write_build_file(build_file_path, contents)

  def format_jar_deps(self, jar_deps, build_file_path):
    """jar_deps - an array of <jar> tags as a dictionary returns a target comprised of jar libs."""
    if not jar_deps:
      return ''

    return Target.jar_library.format(
      name=infer_target_name(build_file_path, 'jar_files'),
      jars=sorted(jar_deps),
    )

  def format_deps(self, target_type, deps, jar_target):
    """deps - an array of <depencency> tags as a dictionary
       returns newline separated references suitable to be included in the BUILD file dependencies
       of a target.
    """
    if target_type == _TARGET_RESOURCES:
      return ''
    deps = sorted(deps or [])
    if jar_target:
      deps.append(jar_target)
    formatted_deps = '\n    '.join('%s,'%dep for dep in deps)
    logger.debug("deps={deps}".format(deps=formatted_deps))
    return deps


  def format_top_level_BUILD(self, pom_dir, path, target_type, target_name, deps):
    """Formats a pants target for a specific target type """

    return Target.dependencies.format(
      name=target_name,
      dependencies=["'%s/%s:%s'" % (pom_dir, path, target_name,)],
    )

  def make_target_if_dir_exists(self, pom_dir, path, target_type, target_name, deps, jar_deps=None,
      resources=None):
    """Checks to see if a directory exists, and if so, formats a pants target for the code in it"""
    target_name = infer_target_name(pom_dir, target_name)
    if os.path.isdir("%s/%s" % (pom_dir, path)):
      self.write_sources_BUILD(pom_dir, path, target_type, target_name, deps, jar_deps, resources)
      return self.format_top_level_BUILD(pom_dir, path, target_type, target_name, deps)
    return ""

  def convertPom(self, pom_file_name, rootdir=None):
    """returns the contents of a BUILD file that corresponds to a module pom.xml file.
       pom_file_name - path to the pom.xml to convert
    """
    deps_from_pom = DepsFromPom(PomUtils.pom_provides_target(),
                                rootdir=rootdir)

    aggregate_lib_deps, aggregate_test_deps = deps_from_pom.get(pom_file_name)
    lib_deps, test_deps, lib_jar_deps, test_jar_deps = [], [], [], []
    for dep in aggregate_lib_deps:
      if dep.find('jar(') != 0:
        lib_deps.append(dep)
      else:
        lib_jar_deps.append(dep)
    for dep in aggregate_test_deps:
      if dep.find('jar(') != 0:
        test_deps.append(dep)
      else:
        test_jar_deps.append(dep)

    pom_dir = os.path.dirname(pom_file_name)
    target_name = os.path.split(pom_dir)[1]
    if pom_dir.startswith("./"):
      pom_dir = pom_dir[2:]

    contents = """# {filepath}
# Automatically generated by {gen_script}
""".format(filepath=infer_build_name(pom_dir), gen_script=os.path.basename(sys.argv[0]))

    # tack on a jvm_binary target if a main class is specified in the pom
    # <properties>
    #   <project.mainclass>com.squareup.service.container.exemplar.ExemplarApp</project.mainclass>
    # </properties>
    main_class = deps_from_pom.get_property('project.mainclass')
    if main_class:
      main_path = main_class.replace('.','/')
      contents += Target.get_template('jvm_binary').format(
        name=infer_target_name(pom_dir, target_name),
        main=main_class,
        basename=deps_from_pom.artifact_id,
        main_source=main_path,
        dependencies=["':{name}'".format(name=infer_target_name(pom_dir, 'lib'))],
      )

    # tack on the targets
    resources = ""
    test_resources = ""
    res_path = "src/main/resources"
    if os.path.isdir(os.path.join(pom_dir, res_path)):
      self.write_sources_BUILD(pom_dir, res_path, _TARGET_RESOURCES, "resources", lib_deps)
      resources = "'%s/%s:resources'" % (pom_dir, res_path)

    test_res_path = "src/test/resources"
    if os.path.isdir(os.path.join(pom_dir, test_res_path)):
      self.write_sources_BUILD(pom_dir, test_res_path, _TARGET_RESOURCES, "resources", [])
      test_resources = "'%s/%s:resources'" % (pom_dir, test_res_path)

    proto_contents = self.make_target_if_dir_exists(
        pom_dir, "src/main/proto", _TARGET_PROTOBUF_LIBRARY, "proto", lib_deps, lib_jar_deps)

    if proto_contents:
      lib_deps.append("'%s/src/main/proto:proto'" % (pom_dir))

    test_proto_contents = self.make_target_if_dir_exists(
      pom_dir, 'src/test/proto', _TARGET_PROTOBUF_LIBRARY, "proto", lib_deps + test_deps)

    if test_proto_contents:
      test_deps.append("'%s/src/test/proto:proto'" % (pom_dir))

    java_contents = self.make_target_if_dir_exists(pom_dir, "src/main/java", _TARGET_JAVA_LIBRARY,
                                               "lib", lib_deps, lib_jar_deps, resources)

    if java_contents:
      test_deps.append("'%s/src/main/java:lib'" % (pom_dir))
    else:
      java_contents += "target(name='{name}')".format(name=infer_target_name(pom_dir, 'lib'))

    test_contents = self.make_target_if_dir_exists(pom_dir, "src/test/java", _TARGET_JUNIT_TESTS,
                                               "test", lib_deps + test_deps,
                                               lib_jar_deps + test_jar_deps, test_resources)


    contents += proto_contents + java_contents + test_contents

    write_build_file(pom_dir, contents)

def is_aux(directory):
  return os.path.exists(os.path.join(directory, _HAND_WRITTEN_BUILD_FILE_NAME))

def infer_target_name(directory, name):
  if name.startswith('aux-'):
    return name # Already aux'd, don't want to do again.
  if is_aux(directory):
    return 'aux-{name}'.format(name=name)
  return name

def infer_build_name(directory):
  if is_aux(directory):
    return os.path.join(directory, _AUX_BUILD_FILE_NAME)
  return os.path.join(directory, _BUILD_FILE_NAME)

def write_build_file(path, contents):
  """Conditionally Write the BUILD file out to the filesystem"""
  outfile_name = infer_build_name(path)
  outfile = open (outfile_name, 'w')
  outfile.write(contents)
  outfile.close()

def main(poms):
  for pom_file_name in poms:
    build_file = PomToBuild().convertPom(pom_file_name)

if __name__ == "__main__":
  args = PomUtils.parse_common_args(sys.argv[1:])
  poms = []
  if (len(args) > 0):
    main(args)
  else:
    print "usage: %s path/to/pom.xml" % (os.path.basename(sys.argv[0]))
    PomUtils.common_usage()
    sys.exit(1)
